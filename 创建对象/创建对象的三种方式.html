<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>创建对象的七种方式</title>
</head>
<body>


<script type="text/html">
    //1.工厂模式
    var person = new Object();
    person.name = "bruce";
    person.age = 20;
    person.job = "software engineer";
    person.sayName = function(){
        console.log(this.name);
    };
    person.sayName();
    //等同
    var person = {
        name : "bruce",
        age : 20,
        job : "software engineer",
        sayName : function(){
            console.log(this.name);
        }
    };
    person.sayName();
    /*
    *优点：创建了单个对象
    * 缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体
    * */

    function createPerson(name,age,job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job= job;
        o.sayName = function(){
            console.log(this.name);
        };
        return o;
    }

    var person1 = createPerson("bruce",20,"software engineer");
    var person2 = createPerson("Lee",22,"Doctor");
    console.log(person1.constructor == createPerson);//false
    console.log(person2.constructor == createPerson);//false
    console.log(person1.constructor);//Object
    /*
    *
    *优点：能够根据接收的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，每次它都会返回一个包含三个属性一个方法的对象
    *缺点：工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）；
    *
    * */

</script>

<script type="text/html">
    /*
    //构造函数模式
    function Person(name,age,job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
          console.log(this.name);
        };
    }
    var person1 = new Person("bruce",20,"software engineer");
    var person2 = new Person("Lee",22,"Doctor");
    console.log(person1.constructor == Person);//true
    console.log(person2.constructor == Person);//true
    //instanceof检测对象类型更可靠
    console.log(person1 instanceof Object);//true
    console.log(person1 instanceof Person);//true
    console.log(person2 instanceof Object);//true
    console.log(person2 instanceof Person);//true

    console.log(person1.constructor);//Person
    /*
    * 优点：解决了对象识别问题；
    * 缺点：每个方法都要在每个实例上重新创建一遍
    * */
    //console.log(person1.sayName == person2.sayName);//false

    //改进
    function Person(name,age,job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = sayName;
    }
    function sayName(){
        console.log(this.name);
    }

    var person1 = new Person("bruce",20,"software engineer");
    var person2 = new Person("Lee",22,"Doctor");
    console.log(person1.sayName == person2.sayName);//true
    /*
    * 新问题：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域名不副实。
    * 其次：若果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了
    * */
</script>

<script>
    /*
    * 原型模式
    * */
    function Person(){};
    Person.prototype.name = "bruce";
    Person.prototype.age = 25;
</script>





</body>
</html>